# Vue 02

## SFC(Single File Component)

### Component(컴포넌트)

기본 HTML 엘리먼트를 확장하여 재사용 가능한 코드를 캡슐화 하는데 도움을 줌

유지보수를 쉽게 만들어 줄 뿐만 아니라, 재사용성의 측면에서도 매우 강력한 기능을 제공함

Vue 컴포넌트 === Vue 인스턴스



### SFC(Single File Component)

Vue의 컴포넌트 기반 개발의 핵심 특징

하나의 컴포넌트는 .vue 확장자를 가진 하나의 파일 안에서 작성되는 코드의 결과물

화면의 특정 영역에 대한 HTML, CSS, JavaScript 코드를 하나의 파일(.vue)에서 관리함

즉, .vue 확장자를 가진 싱글 파일 컴포넌트를 통해 개발하는 방식

Vue 컴포넌트 === Vue 인스턴스 === .vue 파일



단일 파일에서의 개발은 처음 개발을 시작 할 때는 크게 신경 쓸 것이 없어 쉽게 개발이 가능하지만, 코드의 양이 많아지면 변수 관리가 힘들어지고 유지보수에 많은 비용이 발생함

각 기능 별로 파일을 나눠서 개발하면 처음 개발을 준비하는 단계에서 시간 소요가 증가하지만 이후 변수 관리가 용이하고 기능 별로 유지 & 보수 비용이 감소함



### Vue Component 구조 

- 한 화면 안에서도 기능 별로 각기 다른 컴포넌트가 존재함

  하나의 컴포넌트는 여러 개의 하위 컴포넌트를 가질 수 있음

  Vue는 컴포넌트 기반의 개발 환경을 제공함

- Vue 컴포넌트는 const app = new Vue({...}) 의 app을 의미하며 이는 Vue 인스턴스

  여기서 오해하면 안 되는 것은 컴포넌트 기반의 개발이 반드시 파일 단위로 구분되어야 하는 것은 아님 단일 .html 파일 안에서도 여러 개의 컴포넌트를 만들어 개발이 가능함



-> Vue 컴포넌트는 Vue 인스턴스(new Vue({}) 이기도 함

​	Vue 인스턴스는 .vue 파일 안에 작성된 코드의 집합

​	HTML, CSS,  JavaScript를 .vue라는 확장자를 가진 파일 안에서 관리하며 개발함



## Vue CLI

### Vue CLI

Vue.js 개발을 위한 표준 도구

프로젝트의 구성을 도와주는 역할을 하며 Vue 개발 생태계에서 표준 tool 기준을 목표로 함

확장 플러그인, GUI, Bable 등 다양한 tool을 제공함



### Node.js

자바스크립트를 브라우저가 아닌 환경에서도 구동할 수 있도록 하는 자바스크립트 런타임 환경

브라우저 밖을 벗어 날 수 없던 자바스크립트 언어의 태생적 한계를 해결함

 Chrome V8 엔진을 제공하여 여러 OS 환경에서 실행할 수 있는 환경을 제공함

즉, 단순히 브라우저만 조작할 수 있던 자바스크립트를 SSR 아키텍처에서도 사용할 수 있도록 함



###  NPM(Node Package Manage)

자바스크립트 언어를 위한 패키지 관리자

Python에 pip가 있다면  Node.js에는 NPM, pip와 마찬가지로 다양한 의존성 패키지를 관리함

Node.js의 기본 패키지 관리자이며 Node.js 설치 시 함께 설치됨



### 실습



## Bable & Webpack

![vue 프로젝트 구조](vue_0510.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-16%20012009.jpg)



### Babel

JavaScript compiler

자바스크립트의 ECMAScript 2015+ 코드를 이전 버전으로 번역/변환해 주는 도구

과거 자바스크립트의 파편화와 표준화의 영향으로 코드의 스펙트럼이 매우 다양해졌고 이 때문에 최신 문법을 사용해도 이전 브라우저 혹은 환경에서 동작하지 않는 상황이 발생함

원시 코드(최신 버전)를 목적 코드(구 버전)로 옮기는 번역기가 등장하면서 개발자는 더 이상 내 코드가 특정 브라우저에서 동작하지 않는 상황에 대해 크게 고민하지 않을 수 있게 됨

![babel](vue_0510.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-16%20012345.jpg)



### Webpack

static module bundler

모듈 간의 의존성 문제를 해결하기 위한 도구

프로젝트에 필요한 모든 모듈을 매핑하고 내부적으로 종속성 그래프를 빌드함



### Static Module 

모듈은 단지 파일 하나를 의미(ex. js 파일 하나 === 모듈 하나)

브라우저만 조작할 수 있었던 시기의 자바스크립트는 모듈 관련 문법 없이 사용 됨 하지만 JS와 애플리케이션이 복잡해지고 크기가 커지자 전역 scope를 공유하는 형태의 기존 개발 방식의 한계점이 드러남 그래서 라이브러리를 만들어 필요한 모듈을 언제든지 불러오거나 코드를 모듈 단위로 작성하는 등의 다양한 시도가 이루어짐

<img src="vue_0510.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-16%20012826.jpg" alt="모듈 시스템" style="zoom:50%;" />



### Module 의존성 문제

모듈의 수가 많아지고 라이브러리 혹은 모듈 간의 의존성(연결성)이 깊어지면서 특정한 곳에서 발생한 문제가 어떤 모듈 간의 문제인지 파악하기 어려움 즉, Webpack은 이 모듈 간의 의존성 문제를 해결하기 위해 등장함



### Bundler

모듈 의존성 문제를 해결해주는 작업을 Bundling이라 함

이러한 일을 해주는 도구가 Bundler이고,  Webpack은 다양한 Bundler 중 하나

여러 모듈을 하나로 묶어주고 묶인 파일은 하나(혹은 여러개)로 합쳐짐

Bundling된 결과물은 더 이상 순서에 영향을 받지 않고 동작하게 됨

ex.snowpack, parcel, rollup.js 등



-> Vue CLI는 이러한 Babel, Webpack에 대한 초기 설정이 자동으로 되어 있음



![정리](vue_0510.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-16%20013354.jpg)



### Vue 프로젝트 구조

![vue 프로젝트 구조_1](vue_0510.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-16%20013428.jpg)

![vue 프로젝트 구조_2](vue_0510.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-16%20013454.jpg)

![vue 프로젝트 구조_3](vue_0510.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-16%20013510.jpg)

![vue 프로젝트 구조_4](vue_0510.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-16%20013527.jpg)

![vue 프로젝트 구조_5](vue_0510.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-16%20013556.jpg)



## Pass Props & Emit Events

Vue app은 자연스럽게 중첩된 컴포넌트 트리로 구성됨

컴포넌트간 부모-자식 관계가 구성되며 필연적으로 의사 소통이 필요함

부모는 자식에게 데이터를 전달(Pass props)하며, 자식은 자신에게 일어난 일을 부모에게 알림(Emit event)

 -> 부모는 props를 통해 자식에게 '데이터'를 전달하고, 자식은 events를 통해 부모에게 '메세지'를 보냄



### 컴포넌트 구조

![컴포넌트 구조_1](vue_0510.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-14%20014946.jpg)

![컴포넌트 구조_2](vue_0510.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-14%20015114.jpg)

![컴포넌트 구조_3](vue_0510.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-14%20015220.jpg)

![컴포넌트 구조_4](vue_0510.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-14%20015705.jpg)



### 컴포넌트 등록 3단계

1. 불러오기(import)
2. 등록하기(register)
3. 보여주기(print)

![컴포넌트 등록](vue_0510.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-14%20021020.jpg)



### Pass Props & Emit Events

![Pass Props & Emit Events](vue_0510.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-14%20020901.jpg)

### Props

props는 부모(상위) 컴포넌트의 정보를 전달하기 위한 사용자 지정 특성

자식(하위) 컴포넌트는 props 옵션을 사용하여 수신하는 props를 명시적으로 선언해야 함

즉, 데이터는 props 옵션을 사용하여 자식 컴포넌트로 전달됨

주의!

모든 컴포넌트 인스턴스에는 자체 격리된 범위가 있음

즉, 자식 컴포넌트의 템플릿에서 상위 데이터를 직접 참조할 수 없음



### Static Props 작성

![props](vue_0510.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-10%20132134.jpg)

자식 컴포넌트(MyHeader.vue)에 보낼 prop 데이터 선언

수신 할 prop 데이터를 명시적으로 선언 후 사용함

Props 이름 컨벤션

during declarations(선언 시) camelCase, in template(HTML) kebab-case

![컴포넌트의 data](vue_0510.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-14%20022552.jpg)

### Props 시 자주하는 실수

Static 구문을 사용하여 숫자를 전달하려고 시도하는 것

실제 JavaScript 숫자를 전달하려면 값이 JavaScript 표현식으로 평가되도록 v-bind를 사용해야함

![props시 자주하는 실수](vue_0510.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-14%20022711.jpg)



### 단방향 데이터 흐름

모든 props는 하위 속성과 상위 속성 사이의 단방향 바인딩을 형성함

부모의 속성이 변경되면 자식 속성에게 전달되지만, 반대 방향으로는 안 됨

자식 요소가 의도치 않게 부모 요소의 상태를 변경하여 앱의 데이터 흐름을 이해하기 어렵게 만드는 일을 방지함

부모 컴포넌트가 업데이트될 때마다 자식 요소의 모든 prop들이 최신 값으로 업데이트됨



### Emit event

Listening to Child Components Events

$emit(eventName)

현재 인스턴스에서 이벤트를 트리거

추가 인자는 리스너의 콜백 함수로 전달함

부모 컴포넌트는 자식 컴포넌트가 사용되는 템플릿에서 v-on을 사용하여 자식 컴포넌트가 보낸 이벤트를 청취

하위 컴포넌트의 이벤트명 / 상위 컴포넌트의 메서드명

### Emit event 작성

1. 현재 인스턴스에서 $emit d스턴스 메서드를 사용해 child-input-change 이벤트를 트리거

![emit event](vue_0510.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-14%20024113.jpg)



2. 부모 컴포넌트(App.vue)는 자식 컴포넌트(About.vue)가 사용되는 템플릿에서 v-on directive를 사용하여 자식 컴포넌트가 보낸 이벤트(child-input-change)를 청취함

![emit event_2](vue_0510.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-14%20024049.jpg)



event 이름 컨벤션

컴포넌트 및 props와 달리, 이벤트는 자동 대소문자 변환을 제공하지 않음

HTML의 대소문자 구분을 위해 DOM 템플릿의 v-on 이벤트 리스너는 항상 자동으로 소문자 변환되기 때문에 v-on:myEvent는 자동으로 v-on:myevent로 변환됨

이러한 이유로 이벤트 이름에는 항상 kebab-case를 사용하는 것을 권장함

![event 이름 컨벤션](vue_0510.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-14%20024838.jpg)



여기에 들어가는 값은 data나 computed를 뒤짐

표현식이 false가 되면 안보이는건 똑같지만 v-if는dom 자체를 삭제

v-show는 css속성 display none 해버림

vue에서는 eventListener 대신 v-on

모든 event는 첫번째 파라미터로 event가 넘어옴

여기 입력하면 event 트리거가 발생해서 message가 바뀌고 vue가 돔구조에 바로 반영해주는구나! 왕!

input의 안쪽까지 값이 바인딩되서 같이 바뀜

 v-model로 이게 가능해짐!

watch는 속성 특정 값 변경 특정 함수 실행 해주는 속성!

watch 이전의 값은 두번째 새로운 값은 첫번째 파라미터 return언 없어도 됨

computed는 데이터의 확장버전 데이터가 조금 더 다른 모양으로 변경된거?

어떠한 값이 변경되었을 때, 새로운 값을 생성하거나 변경하거나 하고 싶을 때 사용함

이외에 조금 더 무거운 로직들 여기있는  숫자가 변할때마다 비동기통신을 해줘야한다거나.. 여러개의 함수를 묶어서 실행해야한다거나 할 때는 watch를 사용함

computed는 항상 return을 해줘야함 특정 데이터를 가공해서 다른값을 생성하거나 계산할때

watch computed와 똑같이 변화에 대한 트리거는 변화지만 computed보다 조금더 무거운 작업을 하거나 여러개의 함수를 실행할 때

어떤것이 더 좋다 나쁘다가 아니라 그 역할이 좀 다를뿐..!

13번 굉장히 자주 쓰이는 패턴!! 값이 변경될 때마다 클래스를 다르게 주고싶을때..?

for 반복가능한 객체를 반복해서 렌더링해줌

v-for v-if의 우선순위 때문에 같이 쓰는걸 권하지 ㄴㄴ

우리는 자연스럽게 v-for가 먼저 우선순위고 그 다음이 v-if

근데 vue3에서는 우선순위가 반대라서 에러가 남

하나의 li 태그에서 같이 쓰는게 문제니까 이 둘을 분리하자!

v-for를 사용해서 한겹을 감싸고 아 안에서 v-if가 동작을 하도ㅜㅜㅜㅜㅜㅜㅜㅜㅜㅜㅜㅜ록! 

template 태그는 유저는 볼 수 없지만 vue 내부



뷰는 화면을 쪼개서 

컴포넌트 안에서 속성이 유효함

컴포넌트 단위로 나눠서 개발함

컴포넌트간에 관계가 생김 상하 좌우 관계가 있음 상하는 부모 좌우는 형제

컴포넌트에는 전역 컴포넌트와 지역 컴포넌트가 잇음 

전역 컴포넌트는 여러 vue 인스턴스에서 공통으로 사용이 가능(접근가능)

= vue로 접근 가능한 모든 범위에서 사용가능(접근 가능)

지역 컴포넌트 해당 인스턴스 내에서만 사용이 가능한 컴포넌트



컴포넌트 이름으로 된 태그 작성

개발할 때 전역ㄱ컴포넌트 거의 쓰지 않음

지역 컴포넌트 key 꼭 문자열로 연산하려고해서



컴포넌트간의 통신

두가지!  props event

data의 흐름이 임의로 발생하기 때문에 내가 들고 있는 이 데이터가 어디서 왔는지 알기 위해서 log 다 뒤져서 어쩌구~ 이거 찾는거 귀찮음, 개발 속도가 낮아지고 유지보수 난이도가 엄청 증가

데이터의 흐름을 파악할 수 없다는건 치명적인 단점!

그래서 상위 컴포넌트는 하위 컴포넌트에게 데이터를 내릴 수 있고 하위 컴포넌트는 상위 컴포넌트에게 데이터를 올릴 수 있음

그래서 이렇게 만들었음 방향을  미리 정해놓고 데이터의 흐름을 파악하기 위해서!!

루트 컴포넌트는 ㅍ뷰 인스턴스

상위 컴포넌트의 데이터를 프롭스로 하위 컴포넌트에게 내려줌

상위 컴포넌트 데이터를 바꿔주면 하위 컴포넌트도 같이 바뀜 그게 바로 v-bind 의 속성!!

컴포넌트간 데이터를 연동시켜서 우리가 사용할 수 있음

props는 묻지않고 데이터를 내려보냄

하위 컴포넌트에서 상위 컴포넌트로 데이터를 올리려면 

1. 언제 데이터(이벤트)를 보낼건지 트리거

2. 트리거를 상위컴포넌트가 받아줘야함



저 here라는 이름으로 10을 전송하거에요 제가 한거 이벤트 상위 컴포넌트한테 전달할거에요



콘솔 눌렀을때 10이 뜨는 이유는 이 버튼을 누르면 myEvent method가 실행이 되고 이건 here라는 이름으로 10을 보내는데 이건 상위 컴포넌트에게 here라는 이라는 이름으로 numberEvent method를 실행해줘



같은 레벨간 컴포넌트 통시을 하려면 상위 컴포넌트한테 에밋으로 하위 -> 상위로 데이터 올리고 프롭스로 내가 원하는 데이터를 내리는 방식을 써야 옮길 수 있음

data에 그냥 객체 형태로 못씀 함수 형태로 해서 return에서 객체를 넘겨줘야함

왜? 지금 컴포넌트 형태로 개발해서 하나 만들고 복사해서 여러개 만드려고 하는건데 바로 객체 형태로 써버리면 a,,b,c 가 하나의 데이터를 공유하는 형태가 되어버리는데 우리는 각각의 컴포넌트가 독립적인 형태이길 원하기 때문에 함수형태로 매번 새로운 객체를 리턴해서 하나하나 가지길 원해서..어쩌구..ㅠ.ㅠ



같은 레벨에 잇는 컴포넌트 끼리는 이벤트로 올려서 프롭스로 내려받으면서 주고받아야함!



view-router 이거 도대체 뭔ㄴ데..ㅠ

router 들어온걸 알맞은곳으로 분배해주는것

SPA에서 각 주소별로 렌더링할 컴포넌트를 작성할 수 있게 해줌



hello라는 주소가 들어오면 hello라는 컴포넌트를 렌더링 해주면 되는구나!

router-view 배치해주는거 컴포넌트가 갈아끼워지는 자리

router-link 어떤 router로 갈건지 렌더링이 되면 얘는 a 태그로 바뀜 a href="" 이게 to 속성



지금은 router가 default값으로  해싱을 사용해서 브라우저가 히스토리 API 기능을 구현하고 있음

mode history 해싱을 사용하지 않는 url로 바뀌고 뒤로가기 앞으로가기 모두가 잘 동작하게 됨

router-link router-view 역할

어떻게 만들었는지 기억 routes path component는 전부 정해진 속성이라 우리가 바꿀 수 없음

