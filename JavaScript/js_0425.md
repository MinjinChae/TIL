# JavaScript 01

자바스크립트

사용자 중심 

여기서 말하는 사용자는 개발자

계속 쌓이는 표준성, 하위호완성이 좋음

자바스크립트 자체만으로도 개발을 하는데 얘랑 별개로 웹브라우저는 계속 발전해나가 그러면서  자바스크립트가 각광받고있음 웹브라우저 -> 우리들의 컴퓨터에 직접 접근이 가능함 -> 컴퓨터에 프로그램을 직접 설치하지 않아도 됨

웹 브라우저가 C기반의 아키텍쳐를 지원하려고 함 네이티브같은 성능을 낼 수 있음

PHP ASP 쓰레기야 내 미래를 파는거

AWS 싸피 졸업하고나서 관심 가져야할거

## JavaScript Intro

### 동작 방식

![동작방식](js_0425.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-04-28%20235257.jpg)

서버에서 열심히 조작을 하고  웹문서(HTML)를 주고 이걸 브라우저가 받음 

우리가 이쁜 화면을 볼 수 있는건 브라우저가 받아서 우리한테 보여줘서야!



### 브라우저(browser)

자바스크립트가 각광을 받게 된 이유는 웹 브라우저에 있음 우리의 삶에 깊숙하게 들어온 너..

url을 입력하면 word wide web(www)을 탐색하여 서버와 통신함 

HTML 문서나 파일을 출력하는 GUI 기반의 소프트 웨어 

-> 웹문서를 해석해서 우리한테 화면을 보여주고 파일 또는 이미지를 선택해서 저장하는게 가능함



### JavaScript 필요성

브라우저를 조작할 수 있는 @유일한 언어!! (HTML, CSS는 프로그래밍 언어가 아니야 마크업 언어..!)

'동적'으로 브라우저 화면을 만들기 위해서

 ex. 하트를 클릭하면 색깔이 채워진 하트로 바꿔줌(인스타그램의 좋아요 기능)

=> 우리 눈에 보이는 화면을 동적으로 보여주기 위해서는 자바스크립트가 필요해

![js의 필요성](js_0425.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-04-29%20000545.jpg) 



## Browser

###  브라우저에서 할 수 있는 일

- DOM 조작: 문서(HTML)조작

- BOM 조작

- JavaScript Core(ECMAScript)

  

### DOM

웹 페이지에 나타난 HTML 문서 전체를 각각에 대해 객체로 나타낸것

각각의 요소를 객체로 취급한다는 것이 포인트!!

문서가 객체(object)로 구조화되어 있어 key로 접근 가능함

속성 접근, 메서드 활용이 가능하고 프로그래밍 언어로 조작할 수 있음



브라우저에게 문서를 보내면 실제로는 텍스트 덩어리 그 자체야 이걸 구조화 시키고 구조화된 자료를 DOM 이라고 부름

head, meta, body 각각의 객체들이 트리구조로 이루어져있어!

![dom](js_0425.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-04-29%20001643.jpg)



### Parsing

브라우저가 웹 문서를 구문 분석하고 위와  같은 DOM Tree로 만드는 과정

브라우저마다 탑제된 엔진이 달라서 브라우저마다 속도가 차이가남

구글 크롬이 v8엔진 node.js도 v8엔진 사용

![parsing](js_0425.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-04-29%20002526.jpg)



돔 조작

브라우저의 consol창에서 document.title 하면 탭 제목을 바꿀 수 있음

document. 우리가 원하는 요소에 접근할 수 있음

\# 아이디 . 클래스 이용해서 이렇게 바꿔줘 하는것도 가능함

css도 바꾸고 HTML Tag추가 가능함 -> 눈에보이는 모든걸 조작할 수 있음



### BOM

Browser Object Model

문서뿐만 아니라 브라우저까지 조작 가능함 -> 버튼, URL입력창, 버튼 브라우저까지 조작 가능함

탭안에 문서가 있으니까 브라우저가 더 큰 개념

window 객체는 브라우저의 창(window)를 지칭함

![bom](js_0425.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-04-29%20004735.jpg)





![정리](js_0425.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-04-29%20004918.jpg)



### ECMAScript

정보 통신에 대한 표준을 제정하는 비영리 표준화 기구

규격에 따라 정의한 언어 -> 프로그래밍 언어에 대한 명세

ECMAScript6는 ECMA에서 제안한 6번째 표준 명세

6번째 에디션!! 여러개의 버전이 있는데 구버전 신버전을 나누는게 6! 이정도로만 생각하자

(JS랑 ECMAScript는 같은거)



### 세미콜론

우리가 배운 파이썬에는 세미콜론이 안붙음

자바스크립트는 선택적으로 사용 가능함 하지만 보통 다른 프로그래밍 언어는 무조건 써야함

세미콜론이 없으면 ASI에 의해 자동으로 세미콜론이 삽입됨

본 수업에서는 세미콜론 사용하지 않고 진행할거

쓰는 개발자도 있고 안 쓰는 개발자도 있어서 이건 아주 뜨거운 감자야..

![세미콜론](js_0425.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-04-29%20005323.jpg)



### 코딩 스타일 가이드

![코딩 스타일 가이드](js_0425.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-04-29%20005624.jpg)

Airbnb에어비앤비 스타일 가이드를 따를거야

근데 개발자들은 코드를 작성하고 마지막에 코드 포맷팅 툴을 이용해 코드를 한번에 맞추는 방법으로 하고있음



## 변수와 식별자

### 식별자 정의와 특징

식별자(indentifier)는 변수를 구분할 수 있는 변수명

반드시 문자, 달러($) 또는 밑줄(_)로 시작

대소문자 구분하고 클래스명 외에는 모두 소문자

예약어 사용 불가능 ex. for, if, function 등



### 식별자 작성 스타일

- 카멜 케이스(camelCase)

  시작이 소문자, 중간에 띄어쓰기 부분이 대문자

  변수, 객체, 함수에 사용함

![camelCase](js_0425.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-04-29%20011630.jpg)

- 파스칼 케이스 (PascalCase)

  클래스, 생성자 사용 ex.ModelForm

![PascalCase](js_0425.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-04-29%20011751.jpg)

- 대문자 스네이크 케이스(SNAKE_CASE)

  상수를 정의할 때만 사용(개발자의 의도와 상관없이 변경될 가능성이 없는 값을 의미함)

  API_KEY 정말정말 중요한 애들은 all capital!! 다 대문자, 언더바로 띄어쓰기

![SNAKE_CASE](js_0425.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-04-29%20011751.jpg)



### 변수 선언 키워드

![변수 선언 키워드](js_0425.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-04-30%20180233.jpg)

기존의 파이썬에서는 그냥 변수명 끝 ex. tmp = ~

그런데 자바스크립트는 변수명 앞에 변수 선언 키워드가 필요해! -> let, const가 있어



![선언 할당 초기화](js_0425.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-04-30%20180437.jpg)

자바스크립트에서는 선언과 할당을 분리할 수 있음

1. foo라는 변수를 선언만 할 수 있음

   미리 예약하듯이 이름만 선점가능 그리고 해당 변수명을 찍어보면 내용이 없다고 나와(undefined)

2. 선언과 분리해서 할당

3. 선언과 동시에 할당을 할 수도 있음 

선언 / 할당 / 초기화 세단계가 있는데 마지막꺼를 사용할거야! 



### let과 cosnt - 재할당

![재할당](js_0425.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-04-30%20181041.jpg)

- let

  최초 선언이니까 let을 붙이고 10을 할당 다시 재할당해줌 값은 같지만 할당은 다시한거야!

- const

  반면에  const는 10을 처음에 넣었으면 재할당이 불가능해!!

값이 같냐 다르냐가 아니라 저기 = (할당 기호)기호가 들어갈 수 없음

못하는건 값을 바꾸는게 아니라 재할당!! 값을 바꾸는거랑 재할당은 같은 말이 아니야 

배열에다 append 해주면 이건 값이 바뀐거고 재할당은 아니야 가공은 하되, 재할당은 아닌거

즉 ,const는 = 재할당 사인이 안된다

보통 const를 사용하고 바꿔야 할 게 있으면 그때 let으로 바꿔서 써주자!



### let과 cosnt - 재선언

![재선언](js_0425.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-04-30%20181222.jpg)

한 번 선언을 했으면 다시 let number로 선언 불가능 const도 마찬가지

기존의 값에서 가공을 하는건 가능하다 

const는 절대로 값이 안바뀐다? (X) -> 재할당이 안된다!!(주의하자)



### 블록 스코프

![블록 스코프](js_0425.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-04-30%20181543.jpg)

파이썬의 스코프 LEGB 함수 안에서 스코프를 가짐

자바스크립트는 블록스코프를 가짐 파이썬으로 치면 인덴트!  -> if, for, 함수 등의 중괄호 내부

중괄호를 사용하는데, 이 중괄호 내부에서 일어난 일은 중괄호 내부에서 끝남 블록 바깥에서는 아무도 접근할 수 없어 

방문 나가는 순간 없던 일이야..



### var

- var로 선언한 변수는 재선언, 재할당 모두 가능함

![var](js_0425.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-04-30%20182141.jpg)



- 함수 스코프

![var2](js_0425.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-04-30%20182528.jpg)

함수의 중괄호 내부를 가리킴, 함수 스코프를 가지는 변수는 함수 바깥에서 접근 불가능함



- 호이스팅

![호이스팅1](js_0425.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-04-26%20094717.jpg)

호이스팅 === 감아올리기

변수를 선언 이전에 참조할 수 있는 상황을 말함

변수 선언 이전의 위치에서 접근 시 undefined 반환

-> 브라우저가 웹 문서를 쭉 읽다가 자바스크립트 문서를 읽는데 한 번 쭉 읽으면서 var또는 함수로 지정해놓은걸 쭉 읽어서 기억을 해두고 위쪽 어느 공간에 메모를 해두는데 이걸 호이스팅이라고 함 내가 사용하는 변수 함수를 위쪽 레벨에 옮겨둠 값은 아직 안적는데 변수 선언한 애들만 옮겨둠

![호이스팅2](js_0425.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-04-30%20182541.jpg)

username을 아직 정의 안해서 에러가 나야지 정상인데 한 번 쭉 읽은 다음에 "어 아직 할당 안되었는데 뒤에서 하긴 하더라 음 좋은게 좋은거니까 걍 지금 봐주고 뒤로 넘겨주자~ "그래서 undefined 출력함

반면, let const는 아직 없어! 에러야! 라고 알려줌

정확하게 정의가 안되어있다면 없다라고 나와야함 근데 var는 좋은게 좋은거지~ 근데 사실 안좋아.

아직 선언되지 않은 변수를 출력하면 당연히 에러를 내뱉어야지! 그래서 이제 안써!!!  

결론.. var 사용하지말자 내 머릿속에서 지우자



### let, const, var 비교

![let, const, var](js_0425.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-04-30%20184620.jpg)



## 데이터 타입

자바스크립트의 모든 값은 특정한 데이터 타입을 가지는데 , 크게 원시타입과 참조타입이 있음

![데이터 타입](js_0425.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-04-30%20185453.jpg)

![비교](js_0425.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-04-30%20185540.jpg)

원시타입

call by value 값이 복사

실제값이 복사됨 message랑 greeting은 달라서 

참조타입

call by reference 참조 값이 복사 얆은 복사 깊은복사하려면 다 직접 해줘야함

원시타입들이 여러개가 들어가서 구성된 것

greeting도 같은걸 참조하고 있어서 복사된게 아니라 같은 존재를 두개의 이름으로 부르고 있었다는것



### 원시타입

- 숫자(Number) 타입

![number](js_0425.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-04-30%20190704.jpg)

float, int 이런거 없음(정수, 실수 구분 없음) number 하나의 숫잩 타입! 자바스크립트가 알아서 판단함

NAN(Not-A-Number): 계산 불가능한 경우 반환되는 값

ex. 'Angel' / 1004 => NaN

문자열은 1004으로 나눌 수 없어 이건 숫자가 아니야!

근데 웃긴건 숫자가 아니라면서 숫자라는 데이터에 포함되어 있음 웃경..



- 문자열(String)타입

![string](js_0425.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-04-30%20190717.jpg)

템플릿 리터럴: 따옴표 대신 backtick(`) , 달러($),  중괄호({}) 사용해서 표현식 삽입이 가능함



- undefined

![undefined](js_0425.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-04-30%20190735.jpg)

변수의 값이 없음을 나타내는 데이터 타입

값이 없거나 리턴값이 없으면 해당함수는 무조건 undefined

선언만 해놓고 물어보면 없어!  함수의 리턴값이 없으면 응? 리턴없는데? 없어!

개발자의 의도가 아니야



- null

![null](js_0425.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-04-30%20190749.jpg)

변수의 값이 없음을 의도적으로 표현할 때 사용하는 데이터 타입 그래서 null은 자동생성 되지 않음

여기엔 접근금지! 값이 없어야해! 

null 타입과 typeof 연산자

null 타입은 원시 타입에 속하지만, typeof 연산자의 결과는 object (객체)로 표현됨

null의 typeof는 object 원시타입인데 object? 이건 명백한 오류야 근데 고쳐주지 않음

옛날에는 object 타입이었기 때문에..

null을 object 타입으로 보고 코딩한 코드가 많기 때문에 안고쳐준데

null은 object는 아닌데 typeof를 찍으면 object가 나옴 (참고로 알아두기)



- undefined 타입과 null 타입 비교

![undefined/null](js_0425.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-04-30%20190811.jpg)

undefined 자동으로 할당 null 의도적으로 할당

우리가 코딩하면서 쓰게 되는건 null!



- Boolean 

![boolean](js_0425.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-04-30%20190830.jpg)

논리적 참 또는 거짓을 나타내는 타입

파이썬은 대문자였는데 자바스크립트는 소문자

[] 비어있는 리스트 파이썬에는 false 자바스크립트에서는 true



### 자동 형변환 정리

![자동 형변환 정리](js_0425.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-04-30%20190851.jpg)



## 연산자

### 할당연산자

![할당 연산자](js_0425.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-01%20135915.jpg)

할당과 연산을 동시에!

밑에 있는 두개는 파이썬에서 없었는디..(Increment & Decrement)

num ++ 1을 더하겠다 얘네 왜 존재하는거야? while문 돌릴때를 생각해보면 n이 하나씩 올라가줘야하잖아  +=1 이 생각보다 많이 쓰인다는거 이거를 짧게 쓰라고 만들어준게 ++ 근데 Airbnb Style Guide에서는 +=1 과 같이 더 분명한 표현으로 적을 것을 권장함\



### 비교연산자

![비교 연산자](js_0425.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-01%20135927.jpg)

피연산자들(숫자, 문자, boolean 등)을 비교하고 결과값을 boolean으로 반환하는 연산자

문자열은 유니크도 값을 사용하여 표준 사전 순서를 기반으로 비교

ex. 알파벳끼리 비교

알파벳 순서상 후순위가 더 큼, 소문자가 대문자보다 더 큼



### 동등 비교 연산자(==)

![동등 비교 연산자](js_0425.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-01%20135941.jpg)

두 피연산자가 같은 값으로 평가되는지 비교 후 boolean 값을 반환하는 연산자

비교할 때 암묵적 타입 변환을 통해 타입을 일치시킨 후 같은 값인지 비교함

예상치 못한 결과가 발생할 수 있으므로 잘 쓰지 않음!!



### 일치 비교 연산자(===)

![일치 비교 연산자 ](js_0425.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-01%20135956.jpg)

두 피연산자가 같은 값으로 평가되는지 비교 후 boolean 값을 반환하는 연산자

두 비교 대상의 타입과 값이 모두 같은지 비교하는 엄격한 비교가 이루어져 암묵적 타입 변환이 발생하지 않음

=== 이거써야함!!

자바스크립트에서는 =, ===만 쓰면 됨



### 논리 연산자

![논리 연산자](js_0425.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-01%20140752.jpg)

이게 조금더 범용적인 논리 연산자

&& || !

파이썬은 not true 자바스크립트는  !true 

bonjour 자체가 ture니까 ! 를 붙이면 false가 됨



### 삼항 연산자

![삼항 연산자](js_0425.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-01%20140035.jpg)

세 개의 피연산자를 사용하여 조건에 따라 값을 반환하는 연산자

앞에 있는 조건식이 참이라면 콜론(:) 앞의 값을 사용하고 그렇지 않으면 콜론(:) 뒤의 값을 사용

값으로 평가 받기 때문에 변수에 할당 가능함!!

간단하게 말해서 항이 세개가 필요해! -> true 1 2

단항 연산자: 항이 하나만 필요한 연산자 ex. - -> -1 -로 음수 처리 하나만 있어도 값을 바꿀 수 있음

이항 연산자:  항이 두개가 필요한 연산자 ex. - -> 4 - 2 마이너스는 일항 연산자로 존재할때랑 이항 연산자로 존재할때 역할이 다름

최종적으로는 -1, 2 라는 값으로 평가가됨



## 조건문

### if statement

![if](js_0425.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-01%20142502.jpg)

조건은 소괄호 안에 작성함

파이썬에서 elif 가 자바스크립트에서는 else if

실행할 코드는 중괄호{} 안에 작성함 else if가 중괄호 뒤로!

블록 스코프 생성

![if ex](js_0425.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-01%20142524.jpg)



### switch statement

![swithc](js_0425.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-01%20142540.jpg)

표현식의 결과값을 이용한 조건문

표현식의 결과값과 case문의 오른쪽 값을 비교

vreak 및 default문은 선택적??으로 사용 가능?????????????????????

break문이 없는 경우,  break문을 만나거나 default문을 실행할 때까지 다음 조건문 실행

블록 스코프  생성

![switch ex](js_0425.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-01%20142558.jpg)

아오 nation 계속 쓰기 귀찮아! nation값에 대한 비교만 할게 -> switch문 활용

default: 아무것도 처리가 안되면 Hello 출력할게

break는 꼭 써야함 break를 case마다 붙여줘야함!!

![switch ex2](js_0425.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-01%20142623.jpg)

break가 없으면 다 출력하게됨

break없으면 break없는 삶을 사는 switch...

<img src="js_0425.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-01%20152412.jpg" alt="switch break" style="zoom:80%;" />

만약 nation이 France라면? 일단 Korea는 입장못해 어? 프랑스다!ㅍ 프랑스면 어 됐다~ 퇴근 뒤에꺼 알게뭐야 나 퇴근 다 출력하던가 말던가~~

<img src="js_0425.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-01%20152624.jpg" alt="switch break2" style="zoom: 200%;" />

Korea는입장부터 못하고 France다! 출력하고 break 여기서 동작 끝!

근데 switch는 특정 변수에 있는거에 대한 내용만 하는경우에만 쓰고 복합적인거는 못씀



## 반복문

### while

![while](js_0425.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-01%20153233.jpg)

조건문이 참(true)인 동안 반복 시행

조건은 소괄호 안에, 실행할 코드는 중괄호 안에 작성함

블록 스코프 생성

![while2](js_0425.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-01%20153244.jpg)



### for

![for 1](js_0425.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-01%20153258.jpg)

<img src="js_0425.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-04-26%20102457.jpg" alt="for 2" style="zoom: 200%;" />

세미콜론(;)으로 구분되는 세 부분을로 구성

블록 스코프 생성

![](js_0425.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-01%20153329.jpg)



### for ... in

![for...in 1](js_0425.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-01%20153419.jpg) 

![for...in 2](js_0425.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-01%20153435.jpg)

객체(object)의 속성(key)들을 순회할 때 사용함

배열도 순회 가능하지만 권장하지는 않음

실행할 코드는 중괄호 안에 작성

블록 스코프 생성

cf. 여기서 객체는 class의 instance를 말하는게 아니라 dict 딕셔너리를 의미함



in 으로 돌릴때 key값

자바스크립트는 . 으로도 접근이 가능함



### for ... of

![for...of 1](js_0425.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-01%20153452.jpg)

![for...of 2](js_0425.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-01%20153513.jpg)

반복 가능한(iterable)객체를 순회하며 값을 꺼낼 때 사용함-> 배열을 돌릴때는 of!

실행할 코드는 중괄호 안에 작성

블록 스코프 생성

![](js_0425.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-01%20153529.jpg)

array도 for in을 쓸 수 있지만 for in으로 돌리면 idx가 출력됨

딕셔너리는 순서가 없음 우리 눈에 그냥 이렇게 보일 뿐.. 순회하고 싶으면 for in 이 아니라 for of를 쓰면 됨



## 함수

### 자바스크립트에서의 함수의 특징

기억해야할 단 하나! 함수는 값이야

함수가 값이 되는 순간 실행할 수 있다는 특징만 있을 뿐 얘네랑 다른게 없음

이러한 특징을 가진 애들을 일급객체라고함

![일급객체](js_0425.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-04-26%20103730.jpg)



### 함수 선언식

![함수 선언식](js_0425.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-01%20180820.jpg)

함수의 이름과 함께 정의하는 방식

함수의 이름, 매개변수, 몸통(중괄호 내부)



### 함수 표현식

![함수 표현식](js_0425.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-01%20180834.jpg)

정의한 함수를 별도의 변수에 할당하는 것 

함수의 이름(생략 가능), 매개변수, 몸통(중괄호 내부)

함수의 이름을 생략하고 익명함수로 정의가 가능함 

-> 어차피 변수에 할당되어 있으니까 이름 써 줄 필요 없어서 생략해서 많이 사용함

함수를 다른 함수의 값으로써 할당한게 함수 표현식

익명 함수: 이름이 없는 함수, 함수 표현식에서만 가능



### 기본 인자

![기본 인자](js_0425.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-01%20180852.jpg)

'=' 문자 뒤 기본 인자 선언 가능, 아무것도 넘겨주지 않으면 defaul값이 출력됨



### 매개변수와 인자의 개수 불일치 허용

- 매개변수보다 인자의 개수가 많은 경우

![매개변수와 인자](js_0425.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-01%20180906.jpg)

twoArgs의 경우, 매개변수와 인자의 개수 불일치를 허용해서 앞에 잘라서 두개만 출력해줌

- 매개변수보다 인자의 개수가 적은 경우

![매개변수와 인자2](js_0425.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-01%20180921.jpg)

인자를 넘겨 주지 않아서 undefined가 출력됨



### Rest Parameter

![rest parameter](js_0425.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-01%20182300.jpg)

함수 매개 변수의 ...을 Rest parameter 라고 함 들어오는 매개변수를 배열로 만들어 줌

인자가 넘어오지 않으면 빈배열로 처리가 됨



### Spread operator

![spread operator](js_0425.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-01%20182312.jpg)

펼칠 때 ... 사용할 수 있음 한겹 벗기기! -> spread operator 리스트를 펼쳐주는거



## 선언식 vs 표현식

### 함수의 타입

선언식 함수와 표현식 함수 모두 타입은 function

![함수의 타입](js_0425.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-01%20183223.jpg)



### 호이스팅 

함수 선언식은 호이스팅이 일어나고 함수 표현식은 무슨짓을해도 호이스팅이 일어나지않음

#### 함수 선언식

![함수 선언식](js_0425.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-01%20183303.jpg)

#### 함수 표현식

![함수 표현식](js_0425.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-01%20183317.jpg)

![함수 표현식-var](js_0425.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-01%20183334.jpg)

var도 호이스팅이 일어나서 메모장에 적어뒀어 있긴있어 그런데 선언부가 실행되기 전에 얘가 함수인지 object인지 모르는 상황이기 때문에 애를 undefined로 처리함  ???????????



## Arrow Function

함수를 비교적 간결하게 정의할 수 있는 문법

- function을 생략할 수 있음

- 소괄호도 귀찮아 매개변수가 한개일 경우에는 소괄호마저 생략 가능

- 로직이 한줄이면 {}와 return 마저 생략 가능함

![arrow function](js_0425.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-05-01%20184218.jpg)



함수를 어디서 콜하는게 중요한게 아니라 어디서 선언하는게 중요함

'Lexical Scope'

![lexical scope](js_0425.assets/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202022-04-26%20130835.jpg)



## 문자열



## 배열





const

let 

차이점 셤!!!!!!!!!!!!!!!!!!









