# DB 02

## Model Relationship 1

### Foreign Key

- 외래 키(외부 키)

- 관계형 데이터베이스에서 한 테이블의 필드 중 다른 테이블의 행을 식별할 수 있는 키

  -> 하나의 테이블의 필드가 다른 테이블의 행을 참조할 수 있다는 뜻

- 참조하는 테이블에서 속성(필드)에 해당하고 이는 참조되는 테이블의 기본 키(Primary Key)를 가리킴

- 참조하는 테이블의 외래 키는 참조되는 테이블 행 1개에 대응됨

  -> 참조하는 테이블에서 참조되는 테이블의 존재하지 않는 행을 참조할 수는  없음

- 참조하는 테이블의 행 여러 개가 참조되는 테이블의 동일한 행을 참조할 수 있음

  -> 외래 키의 각각의 값들이 같은 행을 참조할 수 있음

(참조하는, 참조되는 헷갈리지 말자!)



### Froeign Key 예시

Article 과 Comment

Article 은 1, Comment 는 N

하나의 게시물에 여러개의 댓글이 작성될 수 있음



하나의 게시글에는 여러개의 댓글이 달릴 수 있음 지금은 하나씩 밖에 안달렸는데 여기서 여러개의 댓글이 달린다면 어떻게 될까..?? Ariticle의 행을 하나 더 늘려야하는걸까..?

댓글을 쓸 때마다 증식...? -> 이상해

FK에 숫자를 넣어줘..? -> 이런 데이터 타입은 지원해주지 않아!

생각의 전환!

Foreign Key를 Comment에 달면 어떨까??

오..해결완료! Comment에서 쓰는 FK는 Article에서 쓰는 pk(id)의 값!

참조하는 모델(Comment)에서 외래 키는 참조되는 모델(Article)의 기본 키(Primary Key)를 가리킴



여기서 알 수 있는 특징!

1. Comment의 필드 값 하나가 Article의 행 하나를 대응함

   -> 참조하는 테이블의 foreign key는 참조되는 테이블의 하나의 행 값에 대응이 됨

2. 참조하는 테이블은 참조되는 테이블의 같은 값을 참조할 수 있음

Aritcle - 참조되는 테이블  Comment - 참조하는 테이블

1 : N 관계에서 외래키는 누가? N이 가지고 있음!

참조하는 테이블 Comment가 FK라는 새로운 컬럼을 가지게 됨

여기서 FK는  Article의 pk값을 쓰는데 Article의 title, content 값을 써도 되지만 얘네는 값이 유일하다고 보장되지 않기 때문에 pk(id)값을 쓰는 거야 



2번 게시글에 작성된 모든 댓글 조회 라던가 이 댓글이 몇번 게시물에 작성된 댓글인지도 조회할 수 있어야 함!

 

### Foreign Key 특징

키를 사용하여 부모 테이블(참조되는 테이블)의 유일한 값을 참조(참조 무결성)

외래 키의 값은 반드시 부모 테이블의 기본 키일 필요는 없지만 유일한 값이어야 함 -> 여기서 유일한 값은? PK(id)

cf. 참조 무결성이란?

데이터베이스 관계 모델에서 관련된 2개의 테이블 간의 일관성을 말함

외래 키가 선언된 테이블(참조하는 테이블)의 외래 키 속성(열)의 값은 그 테이블의 부모가 되는 테이블(참조되는 테이블)의 기본 키 값으로 존재해야 함 -> 다른 중복되는 값 사용 x



### ForeignKey 

얘는 필드 이름이 없음 그냥  ForeignKey

2개의 위치 인자가 반드시 필요함

1. 참조하는 model class
2. on_delete 옵션

migrate 작업 시 필드 이름에 _id를 추가하여 데이터베이스 열 이름을 만듦



comment 모델은 다음과 같은 field를 가지고 있음

외래키 두개의 인자 필수 참조하는 모델, on_delete 옵션

내용 댓글은 제목은 없으니까! 

생성일

수정일

str 객체 프린트 표현 방식 -> content



댓글은 게시판의 기능 중 하나니까 articles의 모델에서 작성해주기

여기서 외래키는 article이라는 변수 여기서 article은 1:N 관계에서 comment가 참조하는모델, 모델 관계에서 참조되는 모델의 단수형 소문자로 작성됨

필드이름은 ForeignKey

필수인자 

첫번째 인자 - 누구를 참조할거야? 위에 있는 Article  class

두번째 인자 - on_delete = models.CASCADE

댓글 내용

생성일

수정일

str 객체



### ForeignKey arguments - on_delete

외래 키가 참조하는 객체가 사라졌을 때 외래 키를 가진 객체를 어떻게 처리할 지를 정의

Database Integrity(데이터 무결성)을 위해서 중요한 설정

즉, Article 객체가 사라졌을 때 게시글이 삭제되었을때 댓글을 어떻게 처리할 것인지에 대한 것

게시글이 있고 그밑에 댓글이 달려있었는데 작성자가 게시글을 지워버렸어! 그럼 게시글을 참조하고 있던 댓글들을 데이터베이스는 어떻게 처리할 것인가!

CASCADE: 부모 객체(참조 된 객체)가 삭제 됐을 때 이를 참조하는 객체도 삭제

나머지 옵션들은 읽어보기~~

cf. 데이터 무결성이란?

데이터의 정확성과 일관성을 유지하고 보증하는 것을 가리키며 데이터베이스나 RDBMS 시스템의 중요한 기능

우리는 참조 무결성에 집중!

FK개념과 관련

FK 값이 데이터베이스의 특정 테이블의 PK 값을 참조하는 것



models.py에 변경사항이 생겼으니까 Migration 해주기



정의할 때는 첫번째에 외래키를 정의해줬는데 실제로 설계도를 만들 때는 마지막 필드로 만들어짐

models.py에 작성하는 외래키 순서는 상관이 없음 어차피 migrate를 하면 마지막 끝에 붙음



만들어진 테이블의 이름 articles_comment

마지막 컬럼이름은 article_id

우리가 models.py 에 썼던 이름은  article = models.ForeignKey~

외래키를 만들면 우리가 만든 클래스의 이름에 _id가 붙어서 생성됨

여기서 실수를 많이 함

ex. Comment 모델은 외래키 article_id를 포함합니다.

class Comment(models.Model):

​	article_id = models.ForeignKey~

-> 이렇게 쓰면 걸리는거야 ㅠㅠ 그럼 article_id_id가 되어버림 주의해야해..!

참조한 테이블의 소문자 단수형으로 쓰는 이유는 외래키 필드 이름을 봤을 때 누구를 참조하는지 명확하게 알아야하기때문에!

1. 누구를 참조하는지 알 수 있음

2. 다른 모델관계와 헷갈리지 않을 수 있음

   1:N 관계인지 M:N관계인지 헷갈릴 수 있음 M:N은 복수형을 쓸거야~

기능상으로 무조건 이렇게 해야하는건 아니지만 그냥 이게 알기 쉬우니까~

 

### 댓글 생성 실습

Comment라는 클래스로 comment라는 인스턴스 생성

1.댓글의 내용 2. 어떤 게시글에 달릴건지 두개의 내용을 comment에 채워야 함

댓글의 내용만 입력하면 에러가 떠

게시글 생성 후에 댓글 생성을 재시도해보자!

실제로 테이블의 컬럼명은 comment.article_id= article.pk (타입을 맞춰서 값을 찍어서 넣어줘야함)

클래스는 comment.article= article (그냥 객체 넣어주면 됨) -> 우리는 ORM을 쓰고 있고 장고는 이걸 더 선호함



이 1번 댓글은 1번 게시글에 작성된 댓글 테이블만 봐도 알 수 있음

이 댓글은 몇 번 게시글에 달린거야? article 객체가 출력됨

외래키를 가지고 있는 입장이기 때문에 참조하는 대상을 한방에 리턴할 수 있음

이 댓글이 달린 article은 몇 번 글이야?

이 댓글이 달린 게시글의 내용은 뭐야?

 comment는 외래키를 가지고 있기 때문에 article 객체를 참조할 수 있고   article 객체가 return 되었기 때문에 article 객체의 속성값들을 확인할 수 있음



두번째 댓글 작성

인스턴스 생성과 동시에 작성

이 댓글이 적힌 게시글의 pk 값은 뭐야?

comment.article.pk -> 객체로 접근

comment.article_id -> 테이블의 물리적인 필드로 접근

comment.article_pk 이건 안됨!! 이런 필드는 없잖아.. @실수하지말자@



### adimin site에서 작성된 댓글 확인

admin site에 등록한다 뭐를? Comment를!



Article과 Comment는 1:N관계야

우리는 지금까지의 실습에서 comment를 만들고 만든 comment 인스턴스를 이용해서 Article을 조회했음(참조)

comment.article 이렇게! article이라는 클래스 변수를 comment에 필드를 작성했으니까!

문제는 Article에서  comment를 어떻게 조회할 수 있을까? 역참조!

외래키가 없는 쪽, 모델 관계형 필드가 없는 쪽에서 자신을 참조하는 누군가를 참조하는 것을 역참조라고 함

comment에는 article이라는 필드가 물리적으로 존재했음 하지만 Article 모델은 그대로.. 

article.comment_set 이라는 새로운 모델 변수를 만들어줌 자신을 참조하고 있는 모델명 +_set

Article이 comment를 참조하는건 이 게시글에 달린 모든 댓글을 조회할 때!



참조 vs 역참조 헷갈리지말자!

필드를 가지고 있는쪽에서 참조하는게 참조

참조를 당하는 입장에서 역으로 하는게 역참조



### 1:N 관계 related_manager

- 역참조('comment_set') 

  Article(1) - > Comment(N)

  article.comment 형태로 사용할 수 없음 article.comment_set manager가 생성됨

  -> 외래키를 가지고 있는 모델명_set 

  항상 comment_set이 되는건 아니야

  게시글에 몇 개의 댓글이 작성 되었는지 django ORM은 보장할 수 없기 떄문

  article은 comment가 잇을 수도 있고 없을 수도 있고

  실제로 Article 클래스에는 Comment와의 어떠한 관계도 작성되어 있지 않음

  Article 클래스에는 comment에 관한 클래스 변수를 한번도 작성한 적이 없잖아!!



- 참조('article')

  Comment(N) -> Article(1)

  댓글의 경우 어떠한 댓글이든 반드시 자신이 참조하고 있는 게시글이 있으므로 comment.article과 같이 접근할 수 있음

  실제 ForeignKey 또한 Comment 클래스에서 작성됨

  외래키를 가지고 있기 때문에 가능함



모든 댓글 조회하기

중간에 매니저만 바뀌는 것

이 게시글에 달린 댓글은 2개야~

여기서 조회한 걸 comment라는 변수에 할당을 하고 for문으로 돌려줌

각각의 댓글을 내용을 출력하고 싶다면 comment.content

이걸 템플릿에서 쓰겠지? 오!



all은 쿼리셋 get은? 















1:N

Foreign Key

한 테이블의 필드(참조) 중 다른 테이블(참조되는)의 행을 식별할 수 있는 키

참조되는 테이블의 기본 키를 가리킴



부모 테이블 참조되는 테이블

참조 무결성 -  일관성

그 테이블의 부모가 되는 테이블의 기본 키 갑스로 존재해야함ㅊ



articcle_id 아니야

참조하는 모델의 소문자 단수형



댓글을 작성하는데 채워야하는 2가지

(댓글의 내용, 어떤 게시글에 달리는지)



참조하는 대상을 한번에 return 할 수 있음



역참조 comment_set 이름을 바꿀 수 있음

class Comment

related_name = 'comments' 로 이름 바꿀 수 있지만 migrations  다시 해줘야함

하지만 바꾸는걸 권장하지 않음..



댓글은 단독 페이지가 없기 때문에 def ccommetns_rquest

if else문 안해도 괜찮음



commit = False 원래 기본값은 True

db에 저장 x 인스턴스 o



Article 모델로부터 pk를 가져오는데 그 pk가 없으면 404에러를 띄워라



유저 대체하는 과정은 필수...!!!



User 모델 요즘 누가써.. 네이버로 로그인하기 이메일로 로그인하지,,

유저가ㅏ 삭제되면 이 코멘트 삭제되야하나? 이게 바로 on delete 이거 옵션인가?



 